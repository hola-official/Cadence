#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

const DEPLOYMENTS_DIR = 'deployments';
const OUTPUT_FILE = '../relayer/src/contracts.ts';

// Chain configurations for relayer
const CHAINS = {
  arcTestnet: {
    chainId: 5042002,
    name: 'Arc Testnet',
    rpcUrl: 'https://rpc.testnet.arc.network',
    usdc: '0x3600000000000000000000000000000000000000',
    // Arc-specific settings
    pollIntervalMs: 15000,
    batchSize: 9000,  // Arc limits to 10k blocks
    confirmations: 2,
    minGasFees: {
      maxPriorityFeePerGas: '1000000000',  // 1 gwei
      maxFeePerGas: '50000000000',          // 50 gwei
    },
  },
  // Future chains (disabled)
  // polygonAmoy: { chainId: 80002, ... },
  // arbitrumSepolia: { chainId: 421614, ... },
};

function loadDeployments() {
  const deployments = {};

  if (!fs.existsSync(DEPLOYMENTS_DIR)) {
    return deployments;
  }

  const files = fs.readdirSync(DEPLOYMENTS_DIR).filter(f => f.endsWith('.json'));

  for (const file of files) {
    const data = JSON.parse(fs.readFileSync(path.join(DEPLOYMENTS_DIR, file)));
    deployments[data.chainId] = data;
  }

  return deployments;
}

function generate() {
  const deployments = loadDeployments();

  // Build chain configs with deployment info
  const chainConfigs = {};

  for (const [key, chain] of Object.entries(CHAINS)) {
    const deployment = deployments[chain.chainId];

    chainConfigs[key] = {
      ...chain,
      policyManagerAddress: deployment?.contracts?.arcPolicyManager || null,
      startBlock: deployment?.deployBlock || 0,
      enabled: !!deployment?.contracts?.arcPolicyManager,
    };
  }

  const output = `// Auto-generated by contracts/scripts/generate-relayer-config.js
// Do not edit manually - run 'make sync' in contracts/ to regenerate

import type { ChainConfig } from './types.js'

// Chain configurations with deployment addresses
export const CHAIN_CONFIGS: Record<string, ChainConfig> = {
${Object.entries(chainConfigs).map(([key, config]) => `  ${key}: {
    chainId: ${config.chainId},
    name: '${config.name}',
    rpcUrl: process.env.${key.replace(/([a-z])([A-Z])/g, '$1_$2').toUpperCase()}_RPC || '${config.rpcUrl}',
    policyManagerAddress: '${config.policyManagerAddress || '0x0000000000000000000000000000000000000000'}' as \`0x\${string}\`,
    startBlock: ${config.startBlock},
    pollIntervalMs: ${config.pollIntervalMs},
    batchSize: ${config.batchSize},
    confirmations: ${config.confirmations},
    enabled: ${config.enabled},${config.minGasFees ? `
    minGasFees: {
      maxPriorityFeePerGas: ${config.minGasFees.maxPriorityFeePerGas}n,
      maxFeePerGas: ${config.minGasFees.maxFeePerGas}n,
    },` : ''}
  }`).join(',\n')}
} as const

// Deployment metadata
export const DEPLOYMENTS = ${JSON.stringify(deployments, null, 2)} as const

// Get enabled chains
export function getEnabledChainConfigs(): ChainConfig[] {
  return Object.values(CHAIN_CONFIGS).filter(c => c.enabled)
}

// Get chain config by ID
export function getChainConfigById(chainId: number): ChainConfig | undefined {
  return Object.values(CHAIN_CONFIGS).find(c => c.chainId === chainId)
}
`;

  fs.mkdirSync(path.dirname(OUTPUT_FILE), { recursive: true });
  fs.writeFileSync(OUTPUT_FILE, output);
  console.log(`  âœ“ Generated ${OUTPUT_FILE}`);
}

generate();
